---
layout: post
title: ìš°í…Œì½” - í†°ìº£ êµ¬í˜„í•˜ê¸° ë¯¸ì…˜ íšŒê³  (feat. ë‚˜ë„ í†°ìº£ ì»¨íŠ¸ë¦¬ë·°í„°..?)
subtitle: ë¶€ì œëª© ì˜ˆì‹œ
tags: woowacourse tomcat
description: >
  í†°ìº£ êµ¬í˜„í•˜ê¸° ë¯¸ì…˜ì„ ì§„í–‰í•˜ë©´ì„œ ìˆì—ˆë˜ ê³¼ì •ì„ íšŒê³ í•´ë³´ì
sitemap: true
hide_last_modified: true
categories:
  - woowacourse
---

![](/assets/img/blog/woowacourse/tom_1.png)

ë ˆë²¨ 1, 2 ë•Œ ë¯¸ì…˜ì„ í•˜ë©´ì„œ ëŠë‚€ ì ì´ ìš°ì„  êµ¬í˜„(ë¦¬íŒ©í„°ë§ì„ ì•½ê°„ ê³ë“¤ì¸)ì„ í•˜ê³  ë‚˜ì„œ ì¶”ê°€ì‹œê°„ì„ ë“¤ì—¬ ë¦¬íŒ©í„°ë§ì„ í•˜ëŠ” ê²Œ ì¢‹ì„ ê²ƒ ê°™ë‹¤ê³  ëŠê¼ˆëŠ”ë° ì´ë²ˆ ë¯¸ì…˜ì— ì ìš©í•´ ë´„ìœ¼ë¡œì¨ í™•ì‹¤íˆ ì´ê²Œ ë‚´ ê°œë°œ ë¼ì´í”„ ì‚¬ì´í´ì¸ ê²ƒì„ ì²´ê°í–ˆë‹¤. ì´ì „ì—ëŠ” êµ¬í˜„ì„ í•˜ë©´ì„œ ë™ì‹œì— ë¦¬íŒ©í„°ë§ë„ ë¹¡ì„¸ê²Œ í•˜ë ¤ë‹¤ ë³´ë‹ˆ ì˜¤íˆë ¤ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ê³¼ í™•ì¥ì„±ì´ ë¨¸ë¦¿ì†ì—ì„œ ê²¹ì³ì„œ ë‡Œì— ê³¼ë¶€í•˜ê°€ ì™€ ì‹œê°„ì´ êµ‰ì¥íˆ ì˜¤ë˜ ê±¸ë ¸ë‹¤.

í•˜ì§€ë§Œ, ì´ë²ˆì—ëŠ” ì²˜ìŒì— êµ¬í˜„ì— ì´ˆì ì„ ë§ì´ ë§ì¶”ê³  êµ¬í˜„ì´ ëë‚˜ê³  ë‚œ ë’¤ ì¶”ê°€ì ìœ¼ë¡œ ë¦¬íŒ©í„°ë§ì„ í•˜ì˜€ëŠ”ë° ì‹œê°„ì ìœ¼ë¡œë„ ì—¬ìœ ë¡œì› ê³  ê´€ì‹¬ì‚¬ë¥¼ ë¶„ë¦¬í•˜ë‹ˆê¹ ë¨¸ë¦¿ì†ìœ¼ë¡œë„ ì—¬ìœ ë¡œì› ë‹¤. í•œ ê°€ì§€ ì•„ì‰¬ì› ë˜ ì ì€ ì´ë²ˆì—ëŠ” ì¢€ ê·¹ì ìœ¼ë¡œ ë§ì´ êµ¬í˜„ì—ë§Œ ì§‘ì¤‘ì„ í•˜ê³  ë¦¬íŒ©í„°ë§ì„ ë§ˆì§€ë§‰ì— ëª°ì•„ì„œ í–ˆì—ˆëŠ”ë° ê·¸ê²ƒë³´ë‹¤ëŠ” êµ¬í˜„ì„ í•˜ë‹¤ê°€ ë¦¬íŒ©í„°ë§ í•  ë•Œê°€ ë”± ë³´ì¼ ë•Œ, ê·¸ ì ì ˆí•œ ë•Œ í•˜ëŠ” ê²ƒì´ ë² ìŠ¤íŠ¸ ì¸ ê²ƒ ê°™ë‹¤. ë¬¼ë¡  ê·¸ ì ì ˆí•œ ë•Œë¥¼ ì°¾ê¸°ê°€ ì‰½ì§€ëŠ” ì•Šê² ì§€ë§Œ ì—°ìŠµí•˜ë‹¤ ë³´ë‹ˆ ì¡°ê¸ˆì”© ê°ì´ ì¡í˜€ê°€ëŠ” ê²ƒ ê°™ë‹¤.

ìš”ì¦˜ ì„¤ê³„ì— ê´€ì‹¬ì´ ë§ì€ë° ë‹¤ìŒ ë¯¸ì…˜ ë•ŒëŠ” íŒ¨í‚¤ì§€ ì˜ì¡´ ìª½ì— ëŒ€í•´ì„œë„ ê³ ë ¤ë¥¼ í•´ì„œ ì§œë³´ë©´ ì¢‹ì„ ê²ƒ ê°™ë‹¤. ë‹¤ìŒ ë¯¸ì…˜ì´ MVC êµ¬í˜„ì´ë¼ ìš”êµ¬ì‚¬í•­ì´ ë¹¡ì„¸ì„œ ê°€ëŠ¥í• ì§„ ëª¨ë¥´ê² ì§€ë§Œâ€¦ ã…‹ã…‹

ì ì´ì œ ë¯¸ì…˜ì„ ë˜ëŒì•„ ë³´ì~ ì „ì²´ ì½”ë“œëŠ” í•´ë‹¹ [ì €ì¥ì†Œ](https://github.com/parkmuhyeun/jwp-dashboard-http/tree/step2)ì— ìˆìŠµë‹ˆë‹¤.

## í†°ìº£ì„ êµ¬í˜„í•´ë¼

![](/assets/img/blog/woowacourse/tom_2.jpeg)

ã…–...? ê°‘ìê¸° í†°ìº£ì„ êµ¬í˜„í•˜ë¼ê³  í•˜ë‹ˆê¹ ë­ë¶€í„° í•´ì•¼ ë ì§€ ë§‰ë§‰í–ˆë‹¤ ã…‹ã…‹ã…‹ ë‚˜ëŠ” ê·¸ë™ì•ˆ í¸ë¦¬í•œ ìŠ¤í”„ë§ ë¶€íŠ¸ë¥¼ ì‚¬ìš©í•˜ì˜€ê³ , ê·¸ ì•ˆì— ë‚´ì¥ í†°ìº£ì´ ì•Œì•„ì„œ ëŒì•„ê°€ê³  ìˆì—ˆê¸° ë•Œë¬¸ì— ë§‰ìƒ í†°ìº£ì´ ì–´ë–»ê²Œ ëŒì•„ê°€ëŠ”ì§€ëŠ” ìƒê°í•´ ë³¸ ì ì€ ì—†ëŠ” ê²ƒ ê°™ë‹¤. ê·¸ë˜ì„œ í†°ìº£ì´ ì–´ë–»ê²Œ ì‘ë™ë˜ëŠ”ì§€ë¶€í„° íŒŒì•…í•  í•„ìš”ê°€ ìˆì—ˆë‹¤.

### 1. í´ë¼ì´ì–¸íŠ¸ ì»¤ë„¥ì…˜ ìˆ˜ë½

ì»¤ë„¥í„°(Connector)ëŠ” í´ë¼ì´ì–¸íŠ¸ì™€ì˜ í†µì‹ ì„ ì²˜ë¦¬í•˜ëŠ”ë° ì„œë²„ì˜ íŠ¹ì • TCP í¬íŠ¸ ë²ˆí˜¸ì—ì„œ ì—°ê²°ì„ ìˆ˜ì‹ í•˜ê³  ìš”ì²­ ì²˜ë¦¬ì™€ ì‘ë‹µì„ ìƒì„±í•œë‹¤ê³  í•œë‹¤. í•´ë‹¹ êµ¬í˜„ ë¶€ë¶„ì„ ë³´ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤. 

```java
    private void connect() {
        try {
            process(serverSocket.accept());
        } catch (IOException e) {
            log.error(e.getMessage(), e);
        }
    }
```

ëŒ€ì¶© ì˜ˆì¸¡í•´ ë³´ë©´ serverSocketì´ ìˆ˜ë½í•œë‹¤ëŠ” ê±° ê°™ì€ë° ì–´ë–¤ ë©”ì„œë“œì¼ê¹Œ? 

> Listens for a connection to be made to this socket and accepts it. The method blocks until a connection is made.

ì´ ì†Œì¼“ì— ì—°ê²°ì´ ì´ë£¨ì–´ì§ˆ ë•Œê¹Œì§€ ê¸°ë‹¤ë ¸ë‹¤ê°€ ì—°ê²°ì„ ìˆ˜ë½í•œë‹¤ê³  ë‚˜ì™€ ìˆë‹¤. í´ë¼ì´ì–¸íŠ¸ê°€ ìš”ì²­ì„ ë³´ë‚´ë©´ ê¸°ë‹¤ë¦¬ë˜ serverSocketì´ ì—°ê²°ì„ ìˆ˜ë½í•˜ê³ , í´ë¼ì´ì–¸íŠ¸ì™€ ë°ì´í„°ë¥¼ ì£¼ê³ ë°›ì„ ìˆ˜ ìˆê²Œ ëœë‹¤.

### 2. ìš”ì²­ ë©”ì‹œì§€ ìˆ˜ì‹ 

ì´ì œ ì—°ê²°ì„ í–ˆìœ¼ë‹ˆ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ë°›ì€ ë°ì´í„°ë¥¼ ì½ì–´ì•¼ê² ì£ ?

```java
@Override
    public void process(final Socket connection) {
        try (final var inputStream = connection.getInputStream();
             final var outputStream = connection.getOutputStream()) {

            ...
        } catch (IOException | UncheckedServletException e) {
            log.error(e.getMessage(), e);
        }
    }
```

InputStreamì„ í†µí•´ HTTP ìš”ì²­ ë©”ì‹œì§€ë¥¼ ë„¤íŠ¸ì›Œí¬ë¡œë¶€í„° ì½ëŠ”ë‹¤. InputStreamì€ ë°”ì´íŠ¸ ê¸°ë°˜ ì…ë ¥ ìŠ¤íŠ¸ë¦¼ ìµœìƒìœ„ ì¶”ìƒ í´ë˜ìŠ¤ì´ê³  XXXInputStreamì´ë¼ëŠ” ë„¤ì´ë°ì„ ê°€ì§„ í•˜ìœ„ í´ë˜ìŠ¤ë“¤ì´ ìˆë‹¤. ê·¸ë¦¬ê³  ë¬¸ì ë‹¨ìœ„ ì…ë ¥ì„ ìœ„í•œ ìµœìƒìœ„ ì…ë ¥ ìŠ¤íŠ¸ë¦¼ í´ë˜ìŠ¤ì¸ Reader(ex.BufferedReadaer)ë¥¼ í†µí•´ ì¢€ ë” í¸ë¦¬í•˜ê²Œ ë¬¸ìë¥¼ ë°›ì•„ë³¼ ìˆ˜ë„ ìˆë‹¤.

### 3. ìš”ì²­ ì²˜ë¦¬, ë¦¬ì†ŒìŠ¤ ë§¤í•‘ê³¼ ì ‘ê·¼, ì‘ë‹µ ìƒì„±

í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ë°›ì€ ë°ì´í„°ë¡œ ì–´ë–¤ ìš”ì²­(ex. "POST /login")ì„ ì²˜ë¦¬í• ì§€ ì–´ë–¤ ë¦¬ì†ŒìŠ¤(ex. login.html)ì— ì ‘ê·¼í• ì§€ë¥¼ ì •í•  ìˆ˜ ìˆì„ ê²ƒì´ê³  ì´ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì‘ë‹µì„ ìƒì„±í•  ê²ƒì´ë‹¤.

```java
    @Override
    public void process(final Socket connection) {
        try (final var inputStream = connection.getInputStream();
             final var outputStream = connection.getOutputStream()) {
            HttpRequest httpRequest = HTTP_REQUEST_PARSER.convertToHttpRequest(inputStream);
            HttpResponse httpResponse = new HttpResponse();

            Controller controller = FRONT_CONTROLLER.handle(httpRequest);
            controller.process(httpRequest, httpResponse);

            ...
        } catch (IOException | UncheckedServletException e) {
            log.error(e.getMessage(), e);
        }
    }
```

ìœ„ì˜ ì½”ë“œëŠ” ì™„ì„±ë³¸ì´ê¸´ í•˜ì§€ë§Œ ìŠˆë„ ì½”ë“œë¥¼ ì‚´í´ë³´ì. InputStreamì„ í†µí•´ ì½ì–´ë“¤ì¸ ë©”ì‹œì§€ë¥¼ ê¸°ë°˜ìœ¼ë¡œ httpRequestë¥¼ ìƒì„±í•˜ê²Œ ë˜ê³  í•´ë‹¹ HttpRequest ì•ˆì—ëŠ” HttpMethod, path, protocol ë“±... ìš”ì²­ ì •ë³´ê°€ ìˆë‹¤. ê·¸ë¦¬ê³  FRONT_CONTROLLERë¼ëŠ” í´ë˜ìŠ¤ì—ì„œ í•´ë‹¹ ìš”ì²­ì•ˆì˜ pathë‚˜ methodë¥¼ ë³´ê³  ì–´ë–¤ controllerë¥¼ ì‚¬ìš©í•´ì•¼ ë ì§€ ë§¤í•‘ì„ í•´ì£¼ê³  í•´ë‹¹ controller ë¡œì§ì„ ì²˜ë¦¬í•œë‹¤.

í•´ë‹¹ ë¡œì§ì„ ì²˜ë¦¬í•˜ê²Œ ë˜ë©´ httpResponse ì•ˆì— ê°ì¢… ì‘ë‹µ ì •ë³´(status code, header, body)ë“¤ì´ ë“¤ì–´ê°€ê²Œ ë˜ê³  ì‘ë‹µì„ ë°˜í™˜í•  ì¤€ë¹„ê°€ ì™„ë£Œëœë‹¤.

### 4. ì‘ë‹µ ë°˜í™˜

ì‘ë‹µì„ ë°˜í™˜í•  ì¤€ë¹„ê°€ ë˜ì—ˆìœ¼ë‹ˆ ì´ì œ ì‘ë‹µì„ ë°˜í™˜í•  ìˆ˜ ìˆë‹¤.

```java
    @Override
    public void process(final Socket connection) {
        try (final var inputStream = connection.getInputStream();
             final var outputStream = connection.getOutputStream()) {
            HttpRequest httpRequest = HTTP_REQUEST_PARSER.convertToHttpRequest(inputStream);
            HttpResponse httpResponse = new HttpResponse();

            Controller controller = FRONT_CONTROLLER.handle(httpRequest);
            controller.process(httpRequest, httpResponse);

            outputStream.write(httpResponse.joinResponse().getBytes());
            outputStream.flush();
        } catch (IOException | UncheckedServletException e) {
            log.error(e.getMessage(), e);
        }
    }
```

httpReseponse.joinResponse()ë¥¼ ê°ì¢… ì‘ë‹µ ì •ë³´ë“¤ì„ Stringìœ¼ë¡œ Join í•œ ë’¤ ë°”ì´íŠ¸ë¡œ ë³€í™˜í•´ì„œ write í•´ì£¼ê³  OutputStreamì„ í†µí•´ ì‘ë‹µ í—¤ë”ë¥¼ í¬í•¨í•œ HTTP ì‘ë‹µ ë©”ì‹œì§€ë¥¼ ìƒì„±í•œë‹¤. OutputStreamì€ ë°”ì´íŠ¸ ê¸°ë°˜ ì¶œë ¥ ìŠ¤íŠ¸ë¦¼ ìµœìƒìœ„ ì¶”ìƒ í´ë˜ìŠ¤ì´ê³  XXXOutputStreamì´ë¼ëŠ” ë„¤ì´ë°ì„ ê°€ì§„ í•˜ìœ„ í´ë˜ìŠ¤ë“¤ì´ ìˆë‹¤.

## êµ¬í˜„ ê³¼ì •

ìš°ì„  ìš”êµ¬ì‚¬í•­ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.

<details>
<summary>ìš”êµ¬ì‚¬í•­</summary>
<div markdown="1">

## 1ë‹¨ê³„ - HTTP êµ¬í˜„í•˜ê¸°

- [x] GET /index.html ì‘ë‹µí•˜ê¸°
- [x] CSS ì§€ì›í•˜ê¸°
- [x] Query String íŒŒì‹±

## 2ë‹¨ê³„ - ë¡œê·¸ì¸ êµ¬í˜„í•˜ê¸°

- [x] HTTP Status Code 302
- [x] POST ë°©ì‹ìœ¼ë¡œ íšŒì›ê°€ì…
- [x] Cookieì— JSESSIONID ê°’ ì €ì¥í•˜ê¸°
- [x] Session êµ¬í˜„í•˜ê¸°

## 3ë‹¨ê³„ - ë¦¬íŒ©í† ë§

- [x] HttpRequest í´ë˜ìŠ¤ êµ¬í˜„í•˜ê¸°
- [x] HttpResponse í´ë˜ìŠ¤ êµ¬í˜„í•˜ê¸°

## 4ë‹¨ê³„ - ë™ì‹œì„± í™•ì¥í•˜ê¸°

- [x] Executorsë¡œ Thread Pool ì ìš©
- [x] ë™ì‹œì„± ì»¬ë ‰ì…˜ ì‚¬ìš©í•˜ê¸°

</div>
</details>

ì²˜ìŒì— êµ¬í˜„ì—ë§Œ ì§‘ì¤‘í–ˆê¸° ë•Œë¬¸ì— ë©”ì¸ ë¡œì§ì´ ëª¨ë‘ Http11Processor í´ë˜ìŠ¤ì— ëª¨ì—¬ìˆì—ˆë‹¤. ê·¸ë˜ì„œ ì½”ë“œ ì¤„ ìˆ˜ë¥¼ ë³´ë©´ ë¬´ë ¤ 260ì¤„ì´â€¦

<details>
<summary>ì²« Http11Processor ì½”ë“œ</summary>
<div markdown="1">

```java
package org.apache.coyote.http11;

import nextstep.jwp.db.InMemoryUserRepository;
import nextstep.jwp.exception.UncheckedServletException;
import nextstep.jwp.exception.UserNotFoundException;
import nextstep.jwp.model.User;
import org.apache.coyote.Cookie;
import org.apache.coyote.HttpStatus;
import org.apache.coyote.Processor;
import org.apache.coyote.Sessions;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.IOException;
import java.net.Socket;
import java.net.URL;
import java.nio.file.Files;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.regex.Pattern;

public class Http11Processor implements Runnable, Processor {

    private static final Logger log = LoggerFactory.getLogger(Http11Processor.class);
    private static final String STATIC_DIRECTORY = "static";
    private static final String SPACE = " ";
    private static final String QUERY_STRING_SEPARATOR = "\\?";
    private static final String MULTIPLE_QUERY_STRING_SEPARATOR = "&";
    private static final String KEY_VALUE_SEPARATOR = "=";
    private static final String LINE_FEED = "\r\n";
    private static final String HTML_SUFFIX = ".html";
    private static final int PATH_INDEX = 1;
    private static final int PROTOCOL_INDEX = 2;
    private static List<String> STATIC_PATH = List.of(".css", ".js");

    private final Socket connection;

    public Http11Processor(final Socket connection) {
        this.connection = connection;
    }

    @Override
    public void run() {
        log.info("connect host: {}, port: {}", connection.getInetAddress(), connection.getPort());
        process(connection);
    }

    @Override
    public void process(final Socket connection) {
        try (final var inputStream = connection.getInputStream();
             final var outputStream = connection.getOutputStream()) {

            byte[] bytes = new byte[2048];
            inputStream.read(bytes);
            final String request = new String(bytes);

            final String response = createResponse(request);

            outputStream.write(response.getBytes());
            outputStream.flush();
        } catch (IOException | UncheckedServletException e) {
            log.error(e.getMessage(), e);
        }
    }

    private String createResponse(String request) throws IOException {

        String path = getPath(request);
        String method = getMethod(request);
        String prevPath = path;
        Cookie cookie = new Cookie();
        Map<String, String> cookies = cookie.getCookies(request);
        String jsessionid = cookies.get("JSESSIONID");
        if (method.equals("GET")) {
            path = processGetRequest(path, jsessionid);
        } else if (method.equals("POST")) {
            if (path.equals("/login")) {
                path = processLogin(request);
            } else if (path.equals("/register")) {
                path = processRegister(request);
            }
        }
        String status = getStatus(prevPath, path);

        String protocol = getRequestElement(request, PROTOCOL_INDEX);
        String contentType = getContentType(path);

        String content = getContent(path);
        String contentLength = "Content-Length: " + content.getBytes().length;

        String response = protocol +  SPACE + status + SPACE + LINE_FEED +
                getJSessionId(request) + SPACE + LINE_FEED +
                contentType + SPACE + LINE_FEED +
                contentLength + SPACE + LINE_FEED +
                getLocationIfRedirect(status, path) +
                LINE_FEED +
                content;
        return response;
    }

    private String getJSessionId(String request) {
        Cookie cookie = new Cookie();
        Map<String, String> cookies = cookie.getCookies(request);
        if (!cookies.containsKey("JSESSIONID")) {
            return cookie.createCookie();
        }
        return "";
    }

    private String processLogin(String request) {
        String path;
        String[] splitRequestBody = getRequestBody(request);
        String account = splitRequestBody[0].split(KEY_VALUE_SEPARATOR)[1];
        String password = splitRequestBody[1].split(KEY_VALUE_SEPARATOR)[1];
        try {
            User user = InMemoryUserRepository.findByAccount(account).orElseThrow(UserNotFoundException::new);
            addSession(request, user);
            path = getRedirectPath(password, user);
            log.info(user.toString());
        } catch (UserNotFoundException e) {
            path =  "/401.html";
        }
        return path;
    }

    private void addSession(String request, User user) {
        Cookie cookie = new Cookie();
        Sessions sessions = new Sessions();
        Map<String, String> cookies = cookie.getCookies(request);
        String jsessionid = cookies.get("JSESSIONID");
        sessions.add(jsessionid, user);
    }

    private static String[] getRequestBody(String request) {
        String[] splitRequest = request.split(LINE_FEED);
        String requestBody = splitRequest[splitRequest.length - 1].trim();
        String[] splitRequestBody = requestBody.split(MULTIPLE_QUERY_STRING_SEPARATOR);
        return splitRequestBody;
    }

    private static String processRegister(String request) {
        String[] splitRequestBody = getRequestBody(request);
        String account = splitRequestBody[0].split(KEY_VALUE_SEPARATOR)[1];
        String email = splitRequestBody[1].split(KEY_VALUE_SEPARATOR)[1];
        email = email.replace("%40", "@");
        String password = splitRequestBody[2].split(KEY_VALUE_SEPARATOR)[1];

        InMemoryUserRepository.save(new User(account, password, email));
        return "/index.html";
    }

    private String getLocationIfRedirect(String status, String path) {
        if (status.startsWith("302")) {
            return "Location: " + path + SPACE + LINE_FEED;
        }
        return "";
    }

    private String getMethod(String request) {
        return getRequestElement(request, 0);
    }

    private String getStatus(String prevPath, String path) {
        if (!isSamePage(prevPath, path) && !prevPath.equals(path)) {
            return HttpStatus.REDIRECT.getHttpStatusCode() + SPACE + HttpStatus.REDIRECT.getHttpStatusMessage();
        }
        return HttpStatus.OK.getHttpStatusCode() + SPACE + HttpStatus.OK.getHttpStatusMessage();
    }

    private static boolean isSamePage(String prevPath, String path) {
        return (prevPath + HTML_SUFFIX).equals(path);
    }

    private String processGetRequest(String path, String jSessionId) {
        if (isRequest(path)) {
            if (haveQueryString(path)) {
               path = processLogin(path);
               return path;
            }
            if (path.equals("/login")) {
                Sessions sessions = new Sessions();
                if (sessions.isAlreadyLogin(jSessionId)) {
                    return "/index.html";
                }
            }
            return path + HTML_SUFFIX;
        }
        return path;
    }

   private String processLogin(String path) {
       String queryString = splitQueryString(path)[1];
       String[] splitQueryString = queryString.split("&");
       String account = splitQueryString[0].split(KEY_VALUE_SEPARATOR)[1];
       String password = splitQueryString[1].split(KEY_VALUE_SEPARATOR)[1];
       try {
           User user = InMemoryUserRepository.findByAccount(account).orElseThrow(UserNotFoundException::new);
           path = getRedirectPath(password, user);
           log.info(user.toString());
           return path;
       } catch (UserNotFoundException e) {
           return "/401.html";
       }
   }

    private String getRedirectPath(String password, User user) {
        String path;
        if (user.checkPassword(password)) {
            path = "/index.html";
        } else {
            path = "/401.html";
        }
        return path;
    }

    private boolean haveQueryString(String path) {
        Pattern pattern = Pattern.compile(QUERY_STRING_SEPARATOR);
        return pattern.matcher(path).find();
    }

    private String getContentType(String path) {
        String contentType = "Content-Type: ";

        if (isStaticPath(path)) {
            return contentType + "text/css;charset=utf-8";
        }
        return contentType + "text/html;charset=utf-8";
    }

    private boolean isStaticPath(String path) {
        for (String staticPath : STATIC_PATH) {
            if (path.endsWith(staticPath)) {
                return true;
            }
        }
        return false;
    }

    private String getContent(String path) throws IOException {
        if (path.equals("/")) {
            return "Hello world!";
        }
        URL resource = getClass().getClassLoader().getResource(STATIC_DIRECTORY + path);
        return new String(Files.readAllBytes(new File(resource.getFile()).toPath()));
    }

    private String getPath(String request) {
        return getRequestElement(request, PATH_INDEX);
    }

    private boolean isRequest(String path) {
        return !isStaticPath(path) && !path.endsWith(HTML_SUFFIX);
    }

    private String[] splitQueryString(String path) {
        return path.split(QUERY_STRING_SEPARATOR);
    }

    private String getRequestElement(String request, int index) {
        return request.split(SPACE + "|" + LINE_FEED)[index];
    }
}
```
</div>
</details>

Oh My Goodness... ğŸ¤®ğŸ¤®ğŸ¤® í•˜ë‚˜ì˜ í´ë˜ìŠ¤ì— ì±…ì„ê³¼ ì—­í™œì´ ë„ˆë¬´ ë§ë‹¤. í•˜ë‚˜ì”© ë¶„ë¦¬í•´ë³´ì

### HttpRequestParser, HttpRequest ë¶„ë¦¬

![](/assets/img/blog/woowacourse/tom_3.png)

HTTP ìš”ì²­ ë©”ì‹œì§€ë¥¼ ë³´ë©´ ìœ„ì™€ ê°™ì´ ë§¤ìš° ë³µì¡í•˜ê²Œ ë˜ì–´ìˆë‹¤. start-line, header, empty line, message bodyê°€ ìˆê³  ë˜ ê·¸ ì•ˆì—ì„œë„ ë‚˜ë‰œë‹¤.

ê·¸ë˜ì„œ êµ¬í˜„í•  ë•Œ ì œì¼ ê±°ìŠ¬ë ¸ë˜ ê²Œ ì½ëŠ” ë¶€ë¶„ì´ì—ˆë‹¤. ì½ì„ ë•Œë§ˆë‹¤ splitì„ í•˜ê³  splitì— ëª‡ ë²ˆì§¸ë¥¼ ê°€ì ¸ì˜¤ê³  ë˜ ê·¸ê±¸ splitì„ í•˜ê³  ã…‹ã…‹ã…‹ ê·¸ë˜ì„œ ì´ ë¶€ë¶„ì„ ê°€ì¥ ë¨¼ì € ë¶„ë¦¬í•˜ìê³  ë§ˆìŒë¨¹ì—ˆë‹¤. ê·¸ë ‡ê²Œ ë‹¤ìŒê³¼ ê°™ì´ HttpRequestParserì„ í†µí•´ ë°ì´í„°ë¥¼ ì½ê³  HttpRequestë¥¼ ë§Œë“¤ì–´ ë‚¼ ìˆ˜ ìˆë„ë¡ ë¶„ë¦¬í•˜ì˜€ë‹¤.

<details>
<summary>HttpRequestParser, HttpRequest ì½”ë“œ</summary>
<div markdown="1">

```java
package org.apache.coyote.http;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.Map;

public class HttpRequestParser {

    private static final int KEY_INDEX = 0;
    private static final int VALUE_INDEX = 1;

    public HttpRequest convertToHttpRequest(InputStream inputStream) throws IOException {
        InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
        BufferedReader bufferedReader = new BufferedReader(inputStreamReader);
        String firstLine = bufferedReader.readLine();
        Map<String, String> header = readHeader(bufferedReader);
        return new HttpRequest(new StartLine(firstLine), header, readMessageBody(bufferedReader, header));
    }

    private Map<String, String> readHeader(BufferedReader bufferedReader) throws IOException {
        Map<String, String> header = new HashMap<>();
        String line = bufferedReader.readLine();
        while (line != null && !line.isBlank()) {
            String[] split = line.split(":");
            header.put(split[KEY_INDEX], split[VALUE_INDEX].strip());
            line = bufferedReader.readLine();
        }
        return header;
    }

    private String readMessageBody(BufferedReader bufferedReader, Map<String, String> header) throws IOException {
        String messageBody = "";
        String contentLengthName = HttpHeader.CONTENT_LENGTH.getName();
        if (header.containsKey(contentLengthName)) {
            int contentLength = Integer.parseInt(header.get(contentLengthName));
            char[] body = new char[contentLength];
            bufferedReader.read(body, 0, contentLength);
            messageBody = new String(body);
        }
        return messageBody;
    }
}
```

```java
package org.apache.coyote.http;

import java.util.Arrays;
import java.util.Map;
import java.util.stream.Collectors;

public class HttpRequest {

    private static final String KEY_VALUE_DELIMITER = "=";
    private static final int KEY_INDEX = 0;
    private static final int VALUE_INDEX = 1;

    private StartLine startLine;
    private Map<String, String> header;
    private Map<String, String> cookies;
    private String messageBody;

    public HttpRequest(StartLine startLine, Map<String, String> header, String messageBody) {
        this.startLine = startLine;
        this.header = header;
        cookies = findCookies();
        this.messageBody = messageBody;
    }

    private Map<String, String> findCookies() {
        return header.entrySet().stream()
                .filter(entry -> entry.getKey().equals("Cookie"))
                .map(entry -> entry.getValue().split("; "))
                .flatMap(Arrays::stream)
                .map(line -> line.split(KEY_VALUE_DELIMITER))
                .collect(Collectors.toMap(line -> line[KEY_INDEX], line -> line[VALUE_INDEX]));
    }

    public boolean containsCookie(String key) {
        return cookies.containsKey(key);
    }

    public String getCookie(String key) {
        return cookies.get(key);
    }

    public void addHeader(String key, String value) {
        header.put(key, value);
    }

    public HttpMethod getMethod() {
        return startLine.getMethod();
    }

    public String getPath() {
        return startLine.getPath();
    }

    public Map<String, String> getQueryStrings() {
        return startLine.getQueryStrings();
    }

    public HttpProtocol getProtocol() {
        return startLine.getProtocol();
    }

    public Map<String, String> getHeader() {
        return header;
    }

    public String getMessageBody() {
        return messageBody;
    }
}
```

</div>
</details>

#### RequestBodyë¥¼ ì½ì„ ë•Œ ë¬´í•œë£¨í”„ì— ë¹ ì§€ëŠ” í˜„ìƒ

HttpRequestë¥¼ ì¢€ ë” í¸ë¦¬í•˜ê²Œ ì½ê¸° ìœ„í•´ BufferedReaderì˜ readLine()ì„ í†µí•´ ì½ì—ˆë‹¤. í•˜ì§€ë§Œ, ì–´ëŠ ë¶€ë¶„ì—ì„œ ê³„ì†í•´ì„œ ë¬´í•œ ë£¨í”„ê°€ ê±¸ë ¤ì„œ ë¸Œë¼ìš°ì €ê°€ ê³„ì† ëŒ€ê¸°í•˜ëŠ” í˜„ìƒì´ ì¼ì–´ë‚¬ë‹¤. í•´ë‹¹ ë¶€ë¶„ì„ ì°¾ê¸° ì‰½ì§€ ì•Šì•„ ëª¨ë“  ê³³ì— ë””ë²„ê¹…ì„ ê±¸ì–´ê°€ë©° í™•ì¸í•œ ê²°ê³¼ BufferedReaderê°€ RequestBody ë¶€ë¶„ì„ ì½ì„ ë•Œ ì œëŒ€ë¡œ ì½ì§€ ëª»í•˜ê³  ë¬´í•œ ë£¨í”„ê°€ ë°œìƒí•˜ëŠ” ê²ƒì„ ë°œê²¬í•˜ì˜€ë‹¤.

í .. ìˆ˜ë§ì€ ì‚½ì§ˆê³¼ ì¶”ë¡ ì„ í•˜ë‹¤ê°€ BufferedReaderì˜ readLine()ì„ ì½ê²Œ ë˜ì—ˆëŠ”ë° ë‹¤ìŒê³¼ ê°™ì€ ì„¤ëª…ì´ ì í˜€ìˆë‹¤.

>Reads a line of text. A line is considered to be terminated by any one of a line feed ('\n'), a carriage return ('\r'), a carriage return followed immediately by a line feed, or by reaching the end-of-file (EOF).

í…ìŠ¤íŠ¸ í•œ ì¤„ì„ ì½ëŠ”ë° ì¤„ ë°”ê¿ˆ('\n'), ìºë¦¬ì§€ ë¦¬í„´('\r'), ìºë¦¬ì§€ ë¦¬í„´ ë‹¤ìŒ ë°”ë¡œ ì¤„ ë°”ê¿ˆ('\r\n')ì´ ì˜¤ê±°ë‚˜ EOFì— ë„ë‹¬í•´ì•¼ ì¢…ë£Œëœ ê²ƒìœ¼ë¡œ ê°„ì£¼í•œë‹¤ëŠ” ê²ƒì´ë‹¤. ì´ê±¸ ë³´ê³  HttpRequestì˜ ë‚´ìš©ì„ ì³ë‹¤ë´¤ë‹¤. start-line + CRLF + header + CRLF + message-bodyì¸ë° message-bodyì˜ ëë¶€ë¶„ì„ ë³´ë©´ ìœ„ì—ì„œ í•´ë‹¹í•˜ëŠ” ì–´ë– í•œ ê²ƒë„ ì—†ë‹¤. ê·¸ë˜ì„œ ëë‚œì§€ ëª¨ë¥´ê³  ê³„ì†í•´ì„œ ë¬´í•œ ë£¨í”„ë¥¼ ëŒê³  ìˆë˜ ê²ƒì´ë‹¤! ğŸ«¢

ê·¸ë˜ì„œ RequestBodyëŠ” ë‹¤ìŒê³¼ ê°™ì´ readë¥¼ ì´ìš©í•˜ì—¬ contentLength ë§Œí¼ ì¶”ê°€ë¡œ ë” ì½ì–´ì£¼ì—ˆë‹¤.

```java
private String readMessageBody(BufferedReader bufferedReader, Map<String, String> header) throws IOException {
        String messageBody = "";
        String contentLengthName = HttpHeader.CONTENT_LENGTH.getName();
        if (header.containsKey(contentLengthName)) {
            int contentLength = Integer.parseInt(header.get(contentLengthName));
            char[] body = new char[contentLength];
            bufferedReader.read(body, 0, contentLength);
            messageBody = new String(body);
        }
        return messageBody;
    }
```

### HttpResponseBuilder, HttpResponse ë¶„ë¦¬ 

![](/assets/img/blog/woowacourse/tom_4.png)

ì‘ë‹µë„ ìœ„ì™€ ê°™ì´ start-line, header, message bodyë¥¼ ì¬êµ¬ì„± í•´ì¤˜ì•¼ ë˜ê¸° ë•Œë¬¸ì— êµ‰ì¥íˆ ì¤‘ë³µëœ ë¶€ë¶„ì´ ë§ì•˜ë‹¤. ê·¸ë˜ì„œ ê·¸ë‹¤ìŒ ë¶„ë¦¬ ëŒ€ìƒìœ¼ë¡œ ì‚¼ì•˜ê³  HttpResponseBudilerë¥¼ ì´ìš©í•´ HttpResponseë¥¼ ìƒì„±í•  ìˆ˜ ìˆë„ë¡ ë¶„ë¦¬í•˜ì˜€ë‹¤. ê·¸ë¦¬ê³  í—¤ë”ë¥¼ ì¶”ê°€í•  ë•Œ ê¸°ì¡´ì˜ í—¤ë”ê°€ ìˆìœ¼ë©´ ê·¸ í—¤ë”ì— ì¶”ê°€ì ìœ¼ë¡œ ì¶”ê°€í•  ìˆ˜ ìˆê²Œ Headerë¼ëŠ” ì¶”ìƒ í´ë˜ìŠ¤ë¥¼ ë§Œë“¤ê³  ì½¤ë§ˆ êµ¬ë¶„ì í—¤ë”(ex. Cache-Control: no-cache, no-store, must-revalidate, max-age=0)ì™€, ì„¸ë¯¸ì½œë¡  êµ¬ë¶„ì í—¤ë”(ex. Set-Cookie: a=b; c=d)ë¥¼ ë¶„ë¦¬í–ˆë‹¤.

<details>
<summary>HttpResponseBuilder, HttpResponse, Header ì½”ë“œ</summary>
<div markdown="1">

```java
package org.apache.coyote.http;

import java.io.IOException;

public class HttpResponseBuilder {

    private static final String LINE_FEED = "\r\n";
    private static final String SPACE = " ";

    private HttpResponseBuilder() {
    }

    public static void buildStaticFileOkResponse(HttpRequest httpRequest, HttpResponse httpResponse, String path) throws IOException {
        try {
            httpResponse.updateFileMessageBody(path);
        } catch (NullPointerException e) {
            buildStaticFileNotFoundResponse(httpRequest, httpResponse);
        }
        String status = joinStatus(HttpStatus.OK.getHttpStatusCode(), HttpStatus.OK.getHttpStatusMessage());
        String protocol = httpRequest.getProtocol().getName();

        String startLine = joinStartLine(status, protocol);
        httpResponse.updateStartLine(startLine);

        httpResponse.addHeader(HttpHeader.CONTENT_TYPE.getName(), ContentType.findType(path));
        httpResponse.addHeader(HttpHeader.CONTENT_LENGTH.getName(), String.valueOf(httpResponse.getMessageBody().getBytes().length));
    }

    public static void buildStaticFileRedirectResponse(HttpRequest httpRequest, HttpResponse httpResponse, String redirectPath) throws IOException {
        String status = joinStatus(HttpStatus.REDIRECT.getHttpStatusCode(), HttpStatus.REDIRECT.getHttpStatusMessage());
        String protocol = httpRequest.getProtocol().getName();
        String startLine = joinStartLine(status, protocol);

        httpResponse.updateStartLine(startLine);
        httpResponse.updateFileMessageBody(redirectPath);

        httpResponse.addHeader(HttpHeader.LOCATION.getName(), redirectPath);
        httpResponse.addHeader(HttpHeader.CONTENT_TYPE.getName(), ContentType.HTML.getType());
        httpResponse.addHeader(HttpHeader.CONTENT_LENGTH.getName(), String.valueOf(httpResponse.getMessageBody().getBytes().length));
    }

    private static String joinStatus(String statusCode, String statusMessage) {
        return statusCode + SPACE + statusMessage;
    }

    private static String joinStartLine(String status, String protocol) {
        return protocol + SPACE + status + SPACE + LINE_FEED;
    }

    public static void buildStaticFileNotFoundResponse(HttpRequest httpRequest, HttpResponse httpResponse) throws IOException {
        String status = joinStatus(HttpStatus.NOT_FOUND.getHttpStatusCode(), HttpStatus.NOT_FOUND.getHttpStatusMessage());
        String protocol = httpRequest.getProtocol().getName();
        String startLine = joinStartLine(status, protocol);

        httpResponse.updateStartLine(startLine);
        httpResponse.updateFileMessageBody("/404.html");

        httpResponse.addHeader(HttpHeader.CONTENT_TYPE.getName(), ContentType.HTML.getType());
        httpResponse.addHeader(HttpHeader.CONTENT_LENGTH.getName(), String.valueOf(httpResponse.getMessageBody().getBytes().length));
    }

    public static void buildCustomResponse(HttpRequest httpRequest, HttpResponse httpResponse, String content) {
        String status = joinStatus(HttpStatus.OK.getHttpStatusCode(), HttpStatus.OK.getHttpStatusMessage());
        String protocol = httpRequest.getProtocol().getName();

        String startLine = joinStartLine(status, protocol);
        httpResponse.updateStartLine(startLine);
        httpResponse.updateMessageBody(content);

        httpResponse.addHeader(HttpHeader.CONTENT_TYPE.getName(), ContentType.HTML.getType());
        httpResponse.addHeader(HttpHeader.CONTENT_LENGTH.getName(), String.valueOf(httpResponse.getMessageBody().getBytes().length));
    }
}
```

```java
package org.apache.coyote.http;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.nio.file.Files;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class HttpResponse {

    private static final String KEY_VALUE_DELIMITER = "=";
    private static final String LINE_FEED = "\r\n";
    private static final String SPACE = " ";
    private static final String STATIC_DIRECTORY = "static";

    private String startLine;
    private Map<String, Header> headers = new HashMap<>();
    private String messageBody;

    public void updateStartLine(String startLine) {
        this.startLine = startLine;
    }

    public void updateMessageBody(String messageBody)  {
        this.messageBody = messageBody;
    }

    public void updateFileMessageBody(String path) throws IOException {
        URL resource = getClass().getClassLoader().getResource(STATIC_DIRECTORY + path);
        messageBody = new String(Files.readAllBytes(new File(resource.getFile()).toPath()));
    }

    public void addHeader(String key, String value) {
        Header header = headers.computeIfAbsent(key, ignore -> new CommaSeperatedHeader());
        header.add(value);
    }

    public void addHeader(String key, List<String> values) {
        Header header = headers.computeIfAbsent(key, ignore -> new CommaSeperatedHeader());
        header.addAll(values);
    }

    public void addCookie(String key, String value) {
        Header header = headers.computeIfAbsent(HttpHeader.COOKIE.getName(), ignore -> new SemicolonSeperatedHeader());
        header.add(key + KEY_VALUE_DELIMITER + value);
    }

    public String joinResponse() {
        return startLine +
                joinCookie() +
                joinHeaderWithoutCookie() +
                LINE_FEED +
                messageBody;
    }

    private String joinHeaderWithoutCookie() {
        String headersWithoutCookie = this.headers.entrySet().stream()
                .filter(entry -> !entry.getKey().equals(HttpHeader.COOKIE.getName()))
                .map(entry -> entry.getKey() + ": " + entry.getValue().getValues())
                .reduce((header1, header2) -> header1 + SPACE + LINE_FEED + header2)
                .orElse("");
        return headersWithoutCookie + SPACE + LINE_FEED;
    }

    private String joinCookie() {
        if (isStaticPath() || !headers.containsKey(HttpHeader.COOKIE.getName())) {
            return "";
        }
        String cookieHeader = headers.get(HttpHeader.COOKIE.getName()).getValues();
        String cookieHeaderResponse = Arrays.stream(cookieHeader.split("; "))
                .map(line -> "Set-Cookie: " + line)
                .reduce((cookie1, cookie2) -> cookie1 + SPACE + LINE_FEED + cookie2)
                .orElse("");

        return cookieHeaderResponse + SPACE + LINE_FEED;
    }

    private boolean isStaticPath() {
        String contentType = headers.get(HttpHeader.CONTENT_TYPE.getName()).getValues();
        return ContentType.isStaticFile(contentType);
    }

    public String getStartLine() {
        return startLine;
    }

    public Map<String, Header> getHeaders() {
        return headers;
    }

    public String getMessageBody() {
        return messageBody;
    }
}
```

```java
package org.apache.coyote.http;

import java.util.Collection;

public abstract class Header {

    protected final Collection<String> values;

    protected Header(Collection<String> values) {
        this.values = values;
    }

    public void add(String value) {
        values.add(value);
    }

    public void addAll(Collection<String> values) {
        this.values.addAll(values);
    }

    abstract String getValues();
}
```

```java
package org.apache.coyote.http;

import java.util.ArrayList;

public class CommaSeperatedHeader extends Header {

    protected CommaSeperatedHeader() {
        super(new ArrayList<>());
    }

    @Override
    String getValues() {
        return String.join(", ", values);
    }
}
```

```java
package org.apache.coyote.http;

import java.util.ArrayList;

public class SemicolonSeperatedHeader extends Header {

    protected SemicolonSeperatedHeader() {
        super(new ArrayList<>());
    }

    @Override
    String getValues() {
        return String.join("; ", values);
    }
}
```
</div>
</details>

### FrontController, Controller ë¶„ë¦¬

ê·¸ë ‡ê²Œ requestì™€ response ë¶€ë¶„ì„ ë¶„ë¦¬í•˜ë‹ˆ ì•ë’¤ëŠ” ê¹”ë”í–ˆì§€ë§Œ ì¤‘ê°„ ë¶€ë¶„ì´ êµ‰ì¥íˆ ë”ëŸ¬ì› ë‹¤.  íŠ¹íˆ ì—„ì²­ë‚˜ê²Œ ë§ì€ ë¶„ê¸°ë¬¸ + if ì¤‘ì²©ë¬¸ì´ í•©ì³ì ¸ì„œ ê°€ë…ì„±ì´ ë§¤ìš° êµ¬ë ¸ë‹¤. ì´ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ì„œëŠ”  methodì™€ pathì— ë”°ë¼ í•´ë‹¹ ë¡œì§ì„ ì²˜ë¦¬í•´ì£¼ëŠ” í´ë˜ìŠ¤ë¥¼ ë§¤í•‘í•´ì£¼ëŠ” ê°ì²´ê°€ í•„ìš”í–ˆë‹¤. ê·¸ë¦¬ê³  ì´ ê°ì²´ê°€ ë°˜í™˜í•´ ì£¼ëŠ” í´ë˜ìŠ¤ë¥¼ ì¶”ìƒí™”í•œ ê°ì²´ê¹Œì§€.

ê·¸ë ‡ê²Œ ì—¬ëŸ¬ ë¶„ê¸°ì˜ Controllerì™€ ì´ Controllerë¥¼ ê³µí†µí™”í•  Controller Interface, ì´ ì»¨íŠ¸ë¡¤ëŸ¬ë¥¼ ë§¤í•‘í•´ì¤„ ê°ì²´ê°€ ìƒì„±ë˜ì—ˆë‹¤. ë§¤í•‘í•´ì£¼ëŠ” ê°ì²´ ì´ë¦„ì„ FrontControllerìœ¼ë¡œ ì§€ì€ ì´ìœ ëŠ” ì—¬ëŸ¬ Controller ì•ì—ì„œ ìš”ì²­ì„ ë°›ì•„ì„œ í•´ë‹¹ Controllerë¡œ ë§¤í•‘í•´ì£¼ê¸° ë•Œë¬¸ì´ì—ˆë‹¤.

<details>
<summary>FrontController, Controller ì½”ë“œ</summary>
<div markdown="1">

```java
package nextstep.jwp.presentation.handler;

import nextstep.jwp.presentation.Controller;
import nextstep.jwp.presentation.LoginController;
import nextstep.jwp.presentation.NotFoundController;
import nextstep.jwp.presentation.RegisterController;
import nextstep.jwp.presentation.RootController;
import nextstep.jwp.presentation.StaticController;
import org.apache.coyote.http.HttpRequest;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class FrontController {

    private static final List<String> STATIC_PATH = List.of(".css", ".js", ".ico", ".html", ".svg");
    private static final Controller NOT_FOUND_CONTROLLER = new NotFoundController();
    private static final Controller STATIC_CONTROLLER = new StaticController();

    private final Map<String, Controller> mappingControllers = new HashMap<>();

    public FrontController() {
        mappingControllers.put("/", new RootController());
        mappingControllers.put("/login", new LoginController());
        mappingControllers.put("/register", new RegisterController());
    }

    public Controller handle(HttpRequest httpRequest) {
        String path = httpRequest.getPath();
        if (isStaticPath(path)) {
            return STATIC_CONTROLLER;
        }
        if (mappingControllers.containsKey(path)) {
            return mappingControllers.get(path);
        }
        return NOT_FOUND_CONTROLLER;
    }

    private boolean isStaticPath(String path) {
        return STATIC_PATH.stream().anyMatch(path::endsWith);
    }
}

package nextstep.jwp.presentation;

import org.apache.coyote.http.HttpRequest;
import org.apache.coyote.http.HttpResponse;

import java.io.IOException;

public interface Controller {
    void process(HttpRequest httpRequest, HttpResponse httpResponse) throws IOException;
}
```
</div>
</details>

### í•˜ë‚˜ì”© ë¶„ë¦¬í•œ ê²°ê³¼

ì´ë ‡ê²Œ í•˜ë‚˜í•˜ë‚˜ ì±…ì„ì„ ë‚˜ëˆ ì£¼ê¸° ìœ„í•´ ë¶„ë¦¬í•œ ê²°ê³¼ ì—„ì²­ë‚˜ê²Œ ëš±ëš±í•˜ë˜ Processorê°€ ë‹¤ìŒê³¼ ê°™ì´ ì„±ê³µì ìœ¼ë¡œ ë‹¤ì´ì–´íŠ¸ë¥¼ í•˜ê²Œ ë˜ì—ˆë‹¤.

```java
package org.apache.coyote.http11;

import nextstep.jwp.exception.UncheckedServletException;
import nextstep.jwp.presentation.Controller;
import nextstep.jwp.presentation.handler.FrontController;
import org.apache.coyote.Processor;
import org.apache.coyote.http.HttpRequest;
import org.apache.coyote.http.HttpRequestParser;
import org.apache.coyote.http.HttpResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.net.Socket;

public class Http11Processor implements Runnable, Processor {

    private static final Logger log = LoggerFactory.getLogger(Http11Processor.class);
    private static final FrontController FRONT_CONTROLLER = new FrontController();
    private static final HttpRequestParser HTTP_REQUEST_PARSER = new HttpRequestParser();

    private final Socket connection;

    public Http11Processor(final Socket connection) {
        this.connection = connection;
    }

    @Override
    public void run() {
        log.info("connect host: {}, port: {}", connection.getInetAddress(), connection.getPort());
        process(connection);
    }

    @Override
    public void process(final Socket connection) {
        try (final var inputStream = connection.getInputStream();
             final var outputStream = connection.getOutputStream()) {
            HttpRequest httpRequest = HTTP_REQUEST_PARSER.convertToHttpRequest(inputStream);
            HttpResponse httpResponse = new HttpResponse();

            Controller controller = FRONT_CONTROLLER.handle(httpRequest);
            controller.process(httpRequest, httpResponse);

            outputStream.write(httpResponse.joinResponse().getBytes());
            outputStream.flush();
        } catch (IOException | UncheckedServletException e) {
            log.error(e.getMessage(), e);
        }
    }
}
```

í˜„ì¬ ë¶„ë¦¬í•œ ë‚˜ì˜ êµ¬ì¡°ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.

![](/assets/img/blog/woowacourse/tom_5.png)

ê·¼ë° ì´ë ‡ê²Œ í•˜ë‚˜í•˜ë‚˜ ë¶„ë¦¬í•´ì„œ êµ¬í˜„í•˜ë‹¤ ë³´ë‹ˆê¹ ìì—°ìŠ¤ëŸ½ê²Œ Servletì˜ êµ¬ì¡°ì™€ ë¹„ìŠ·í•˜ê²Œ ë˜ëŠ” ê²ƒ ê°™ì•˜ë‹¤. ì´ë¯¸ ë¨¸ë¦¬ê°€ ìŠ¤í”„ë§ì— ë„ˆë¬´ ì ˆì—¬ì ¸ì„œ ê·¸ëŸ°ê°€...? ë­ê°€ ë˜ì—ˆë“  êµ‰ì¥íˆ ì˜ë¯¸ìˆëŠ” ê²½í—˜ì´ì—ˆê³  Tomcatê³¼ ì¢€ ë” ì¹œí•´ì§„ ê±° ê°™ë‹¤. ë²Œì¨ë¶€í„° ë‹¤ìŒ ë¯¸ì…˜ì¸ MVC êµ¬í˜„í•˜ê¸°ê°€ ë§¤ìš° ê¸°ëŒ€ëœë‹¤. ğŸ¤—

## ì‹¤ì œ í†°ìº£ì€ ì–´ë–»ê²Œ êµ¬í˜„ë˜ì–´ ìˆì„ê¹Œ?

ë¯¸ì…˜ì„ ì‹œì‘í•  ë•Œ í†°ìº£ì„ ë³´ì§€ ì•Šê³  êµ¬í˜„í•˜ê³  ë‚˜ì¤‘ì— ì‹¤ì œ í†°ìº£ ì½”ë“œì™€ ë¹„êµí•´ ë³´ê³  ì‹¶ì—ˆë‹¤. ê³¼ì—° ì‹¤ì œ í†°ìº£ì€ ì–´ë–»ê²Œ êµ¬í˜„ë˜ì–´ ìˆì„ê¹Œ? ë‚´ê°€ ì²˜ë¦¬í•œ ê²ƒë“¤ì„ ì–´ë–»ê²Œ íš¨ìœ¨ì ìœ¼ë¡œ ì²˜ë¦¬í•˜ê³  ìˆëŠ”ì§€, ì—£ì§€ ì¼€ì´ìŠ¤ëŠ” ì–´ë–»ê²Œ ì²˜ë¦¬í•´ ì£¼ê³  ìˆëŠ”ì§€ ê¶ê¸ˆí–ˆë‹¤.

![](/assets/img/blog/woowacourse/tom_6.png)

ìš°ì„  í†°ìº£ íŒ¨í‚¤ì§€ë¥¼ ë³´ë©´ Catalina, Coyote íŒ¨í‚¤ì§€ê°€ ìˆë‹¤. Catalina íŒ¨í‚¤ì§€ëŠ” ì„œë¸”ë¦¿ ì»¨í…Œì´ë„ˆ ì—­í• ì„ í•˜ë©°, Coyote íŒ¨í‚¤ì§€ëŠ” í†°ìº£ì— TCPë¥¼ í†µí•œ í”„ë¡œí† ì½œì„ ì§€ì›í•˜ëŠ” ì—­í• ì„ í•œë‹¤.

ì²˜ìŒì— ìš”ì²­ì´ ë“¤ì–´ì˜¤ë©´ Connectorë¥¼ í†µí•´ ì—°ê²°ì´ ë˜ê³  Coyote íŒ¨í‚¤ì§€ì˜ Http11Processor í´ë˜ìŠ¤ service() ë©”ì„œë“œê°€ ì‹¤í–‰ì´ ëœë‹¤.

```java
class Http11Processor {

    @Override
    public SocketState service(SocketWrapperBase<?> socketWrapper) throws IOException {

        parse();

        ...

        getAdapter().service(reuqest, reaponse);

        ...

    }
}
```

ìš”ì²­ìœ¼ë¡œ ë“¤ì–´ì˜¨ ë¶€ë¶„ì— ëŒ€í•´ íŒŒì‹±ì´ ì¼ì–´ë‚˜ê³  ê·¸ë¦¬ê³  getAdapter().service(request, response) ë©”ì„œë“œë¥¼ í˜¸ì¶œí•œë‹¤. í•´ë‹¹ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ê²Œ ë˜ë©´ Catalina íŒ¨í‚¤ì§€ì— ìˆëŠ” StandardWrapperValve í´ë˜ìŠ¤ì˜ invoke() ë©”ì„œë“œê°€ ì‹¤í–‰ë˜ê²Œ ë˜ê³  ë‹¤ìŒê³¼ ê°™ì€ ë¡œì§ì„ í†µí•´ ì•Œë§ì€ ì„œë¸”ë¦¿ì„ í• ë‹¹í•œë‹¤. StandardWrapperValve í´ë˜ìŠ¤ëŠ” ê°œë³„ ì„œë¸”ë¦¿ ì •ì˜ë¥¼ ë‚˜íƒ€ë‚´ëŠ” Wrapper ì¸í„°í˜ì´ìŠ¤ì˜ í‘œì¤€ êµ¬í˜„ì´ë‹¤.

```java
class StandardWrapperValve {
    // Allocate a servlet instance to process this request
    @Override
    public void invoke(Request request, Response response) throws IOException, ServletException {
        ...

        try {
            if (!unavailable) {
                servlet = wrapper.allocate();
            }
            ...
        }
        ...
}
```

ì´ë ‡ê²Œ ì„œë¸”ë¦¿ì„ í• ë‹¹í•˜ê³  ë‚˜ë©´ í•´ë‹¹ ìš”ì²­ì— ëŒ€í•œ filter chainì„ í˜¸ì¶œí•œë‹¤. í•´ë‹¹ filter  chainì„ í˜¸ì¶œí–ˆì„ ë•Œ ë‹¤ìŒì— í˜¸ì¶œí•  í•„í„°ê°€ ìˆìœ¼ë©´ ê³„ì†í•´ì„œ í˜¸ì¶œí•˜ë©° ì‘ì—…ì„ ì²˜ë¦¬í•˜ê³  ì—†ìœ¼ë©´ í• ë‹¹ëœ servletì˜ service() ë©”ì„œë“œë¥¼ ì‹¤í–‰í•˜ë©° ë§ˆë¬´ë¦¬í•œë‹¤. ê·¸ë ‡ê²Œ ì„œë¸”ë¦¿ì˜ í•´ë‹¹ ë¡œì§ì„ ì²˜ë¦¬í•˜ê³  ë‚˜ì„œ ì‘ë‹µì„ ë°˜í™˜í•˜ë©´ ëì´ ë‚œë‹¤.

```java
        // Call the filter chain for this request
        // NOTE: This also calls the servlet's service() method
        Container container = this.container;
        try {
            if ((servlet != null) && (filterChain != null)) {
                // Swallow output if needed
                if (context.getSwallowOutput()) {
                    try {
                        SystemLogHandler.startCapture();
                        if (request.isAsyncDispatching()) {
                            request.getAsyncContextInternal().doInternalDispatch();
                        } else {
                            filterChain.doFilter(request.getRequest(), response.getResponse());
                        }
                    } finally {
                        String log = SystemLogHandler.stopCapture();
                        if (log != null && log.length() > 0) {
                            context.getLogger().info(log);
                        }
                    }
                } else {
                    if (request.isAsyncDispatching()) {
                        request.getAsyncContextInternal().doInternalDispatch();
                    } else {
                        filterChain.doFilter(request.getRequest(), response.getResponse());
                    }
                }

            }
        }
        ...
```

í•´ë‹¹ ê³¼ì •ì„ ê°„ë‹¨í•˜ê²Œ ê·¸ë¦¼ìœ¼ë¡œ ë‚˜íƒ€ë‚´ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.

![](/assets/img/blog/woowacourse/tom_7.png)

ì‹¤ì œ êµ¬í˜„ë˜ì–´ ìˆëŠ” í†°ìº£ê³¼ íë¦„ì„ ë¹„êµí•´ ë³´ë©´ ë¹„ìŠ·í•œ ê±¸ í™•ì¸í•  ìˆ˜ ìˆë‹¤. ê·¼ë° ì‹¤ì œ í†°ìº£ ì½”ë“œë¥¼ ë³´ë‹¤ ë³´ë©´ ì½”ë“œê°€ êµ‰ì¥íˆ ê¸¸ê³  ì§€ì €ë¶„í•œ ê±¸ ë³¼ ìˆ˜ ìˆë‹¤. ëŒ€í˜• ì˜¤í”ˆì†ŒìŠ¤ í”„ë¡œì íŠ¸ë‹ˆ ì–´ì©” ìˆ˜ ì—†ê² ì§€ë§Œ ê³¼ì •ì„ í•˜ë‚˜í•˜ë‚˜ ì¶”ì í•˜ë©° ì§ì ‘ ì°¾ì•„ë³´ëŠ” ê²Œ ë„ˆë¬´ í˜ë“¤ì—ˆë‹¤ã…œã…œ ë‚´ê°€ FrontControllerë¼ê³  ì§€ì€ ê°ì²´ëŠ” í†°ìº£ì—ì„œëŠ” Container(ì°¸ê³ ë¡œ, StandardWrapperê°€ Container ì¸í„°í˜ì´ìŠ¤ë¥¼ implements í•˜ê³  ìˆë‹¤) ì™€ ControllerëŠ” Servletê³¼ ëŒ€ì¹­ë˜ê³  ìˆëŠ”ê±¸ í™•ì¸í•  ìˆ˜ ìˆì—ˆë‹¤. ë‚˜ëŠ” ì´ë¯¸ ìŠ¤í”„ë§ì— ë¨¸ë¦¬ ì ˆì—¬ì§„ ê²ƒ í™•ì¸ ğŸ« 

## í†°ìº£ ì»¨íŠ¸ë¦¬ë·°íŠ¸

ì½”ë“œë¥¼ ë¶„ì„ í•˜ëŠ”ë° ì†”ì§íˆ ë§í•˜ë©´ ì½”ë“œê°€ ì •ë§ ê°€ë…ì„±ì´ ì¢‹ì§€ ì•Šì•„ ë³´ê¸° í˜ë“¤ì—ˆë‹¤. ì´ë¯¸ ì˜¤í”ˆì†ŒìŠ¤ í”„ë¡œì íŠ¸ë¥¼ ì°¸ì—¬í•˜ê³  ìˆì–´ì„œ ì˜¤í”ˆ ì†ŒìŠ¤ ì½”ë“œë‚˜ ë¬¸í™”ì— ëŒ€í•´ ìµìˆ™í–ˆê¸° ë•Œë¬¸ì— í†°ìº£ ì˜¤í”ˆì†ŒìŠ¤ë„ ê¸°ì—¬í•´ ë³¼ ìˆ˜ ìˆì§€ ì•Šì„ê¹Œ ìƒê°í–ˆë‹¤.

ê·¸ë˜ì„œ ì´ì „ì— ë³´ë‹¤ê°€ ì¡°ê¸ˆ ë¶ˆí¸í•œ ë¶€ë¶„ì¸ ìƒìˆ˜ ì»¨ë²¤ì…˜ ë¶ˆì¼ì¹˜ì™€ ìŠ¤ìœ„ì¹˜ë¬¸ì— ë§¤ì§ ë„˜ë²„ ì‚¬ìš© ë¶€ë¶„ì„ ë¦¬íŒ©í„°ë§ í•´ PRì„ ì œì¶œí–ˆë‹¤.
- [Unify constant delimiters and Refactoring for better readability](https://github.com/apache/tomcat/pull/659)

![](/assets/img/blog/woowacourse/tom_8.png)

ìƒìˆ˜ ì»¨ë²¤ì…˜ì„ ë³€ê²½í•˜ë©´ 3rd-partyì™€ í†µí•©ì´ ì¤‘ë‹¨ë  ìœ„í—˜ì„±ë„ ìˆê¸° ë•Œë¬¸ì— ì •ë§ íƒ€ë‹¹í•œ ì´ìœ ê°€ ì—†ëŠ” í•œì€ ë³€ê²½í•˜ê³  ì‹¶ì§€ ì•Šë‹¤ê³  í•˜ì—¬ ìƒìˆ˜ ì»¨ë²¤ì…˜ ë¶€ë¶„ì€ ë¡¤ë°± í•˜ì˜€ë‹¤. í•˜ì§€ë§Œ, ë§¤ì§ ë„˜ë²„ ë¶€ë¶„ì€ ë°›ì•„ë“¤ì—¬ì ¸ ê²°êµ­ Mergeê°€ ë˜ì—ˆë‹¤! ë¬¼ë¡  ì˜¤í”ˆì†ŒìŠ¤ì— ì²˜ìŒìœ¼ë¡œ ê¸°ì—¬í•œ ê²ƒì€ ì•„ë‹ˆë¼ ë¯¸ì¹œ ë“¯ì´ ì„¤ë Œ ê±´ ì•„ë‹ˆì§€ë§Œ ê·¸ë˜ë„ ìˆ¨ê¸¸ ìˆ˜ ì—†ëŠ” ì…ê¼¬ë¦¬.. ğŸ«¢

---
ì°¸ê³ :
- [í†°ìº£ ì»¨íŠ¸ë¦¬ë·°í„° ì „ë¹„ë²„](https://jeoninpyo726.tistory.com/81)

*í‹€ë¦° ë¶€ë¶„ì´ ìˆìœ¼ë©´ ì–¸ì œë“ ì§€ ë§ì”€í•´ ì£¼ì‹œë©´ ê³µë¶€í•´ì„œ ìˆ˜ì •í•˜ê² ìŠµë‹ˆë‹¤.